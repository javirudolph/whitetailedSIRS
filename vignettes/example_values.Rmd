---
title: "Introduction to a simple projection using whitetailedSIRS"
author: "F. Javiera Rudolph, Elias Rosenblatt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{example_values}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(whitetailedSIRS)
library(tidyverse)
library(deSolve)
library(rootSolve)
```


As a first example, we will use the defaults for all the values, and run one projection of the SIRS model. These defaults are produced as random draws from the expert elicitation data.

First, load the data, and generate a random sample for each of the parameters using the `draw_elicitation_samples.R` function from the whitetailedSIRS package: 
```{r}
set.seed(23)
nsamples <- 50

EE_data <- whitetailedSIRS::elicitation_data
# bind samples to the elicitation df

draw_elicitation_samples(elicitation_data = EE_data, nsamples = nsamples,seed = 23) -> elicitation_data
```

With the previous code we generated a sample of `r nsamples` values for each of the parameters elicited, using the appropriate distribution. We will use some of those parameters now to calculate our transmission terms and other parameters that go into the SIRS model. The `elicitation_data` object is a tibble, and the sample of values for each parameter is a vector of values within each cell of the tibble for the `my_sample` column:
```{r}
slice_head(elicitation_data, n = 5)
```

We write a short helper function to help us extract each of the vectors in the `my_sample` column, so these can be assigned to the different parameters. This function `get_EE_param_vals.R` is available for use from the whitetailedSIRS package.

```{r}
get_EE_param_vals <- function(my_param){
   elicitation_data %>%
      filter(parameter == my_param) %>%
      unnest(cols = c(my_sample)) %>%
      pull(my_sample)
}
```

We set up all the parameters that were generated from the expert elicitation distributions:

```{r}
# The immunity parameter that goes into the SIR is the reciprocal to what was elicited
alpha_immunity <- 1 / get_EE_param_vals('Temporary Immunity')

# Calculate contact rate between wild deer using the contact_rate fx using defaults:
c_ww <- whitetailedSIRS::calc_contact_rate(nsamples = nsamples, type_contact = "low")
# The rest of the contact rates were elicited and then modified
c_cw <- 0.00072 / get_EE_param_vals("Direct Contact Probability")
c_cc <- get_EE_param_vals("Deer-Deer Proximity Rate, Captive (per day)")
c_hw <- get_EE_param_vals("Deer-Human Proximity Rate, Rural (per 120 days)") / 120
c_hc <- get_EE_param_vals("Deer-Human Proximity Rate, Captive (per 120 days)") /120

# time or duration of these contacts was also expert elicited:
t_contact_deer_deer <- get_EE_param_vals("Deer Proximity Duration (minutes)")
t_contact_deer_human_rural <- get_EE_param_vals("Deer-Human Proximity Duration, Rural (minutes)")
t_contact_deer_human_capt <- get_EE_param_vals("Deer-Human Proximity Duration, Captive (minutes)")

# Viral load proportional to human value:
C_nu <- 10^5.6 * get_EE_param_vals("Viral Load")

# Dose response
r_deer <- get_EE_param_vals("Dose-Response")

# Direct contact probability:
sigma_dc_wild <- get_EE_param_vals("Direct Contact Probability")
sigma_dc_captive <- get_EE_param_vals("Direct Contact Probability")
```


Using the sets of parameters from expert elicitation we calculate probability of infection via aerosol and direct contact. These calculations are also informed by parameters from the literature, and details on this can be found in the `sir_model_description` document/article.


```{r}
# aerosol
nu_aero_deer_deer <- calc_nu_aero(C_nu = C_nu,
                                  t_contact = t_contact_deer_deer / 60,
                                  r = r_deer)

nu_aero_deer_human_rural <- calc_nu_aero(ER = rep(0.53, nsamples), C_nu = C_nu, t_contact = t_contact_deer_human_rural/60, r = r_deer)
nu_aero_deer_human_capt <- calc_nu_aero(ER = rep(0.53, nsamples), C_nu = C_nu, t_contact = t_contact_deer_human_capt/60, r = r_deer)

# direct contact
nu_dc_deer_deer <- calc_nu_dc(C_nu = C_nu)

# Some additional parameters:
gamma_recov <- rep(1/6, nsamples)
I_human <- rep(0.05, nsamples)
boost <- rep(0, nsamples)

```

Now that we have all the parameters we need, we can set up the inputs for the `ode()` function:

```{r}
list_inits <- list(
   S_wild = rep(1, nsamples),
   I_wild = rep(0, nsamples),
   R_wild = rep(0, nsamples),
   S_captive = rep(1, nsamples),
   I_captive = rep(0, nsamples),
   R_captive = rep(0, nsamples)
)

list_inits_cumulative <- list(
   S_wild = rep(1, nsamples),
   I_wild = rep(0, nsamples),
   R_wild = rep(0, nsamples),
   I_wild_cumulative = rep(0, nsamples),
   S_captive = rep(1, nsamples),
   I_captive = rep(0, nsamples),
   R_captive = rep(0, nsamples),
   I_captive_cumulative = rep(0,nsamples)
)

list_params <- list(
   alpha_immunity = alpha_immunity,
   beta_aero_ww = c_ww * nu_aero_deer_deer,
   beta_aero_cw = c_cw * nu_aero_deer_deer,
   beta_aero_cc = c_cc * nu_aero_deer_deer,
   beta_aero_hw = c_hw * nu_aero_deer_human_rural,
   beta_aero_hc = c_hc * nu_aero_deer_human_capt,
   beta_dc_ww = c_ww * sigma_dc_wild * nu_dc_deer_deer,
   beta_dc_cw = c_cw * sigma_dc_wild * nu_dc_deer_deer,
   beta_dc_cc = c_cc * sigma_dc_captive * nu_dc_deer_deer,
   gamma_recov = gamma_recov,
   I_human = I_human,
   boost = boost
)

times <- seq(0, 120, by = 1)
```

We continue to work with list columns here so we can keep track of the sets of parameters associated to each of the projections:

```{r}
# create list column to store inits and params
mytibble <- tibble(run_id = 1:nsamples,
                   inits.outbreak = map(run_id, ~ list_inits_cumulative %>% map_dbl(., .x)),
                   inits.steady = map(run_id, ~ list_inits %>% map_dbl(., .x)),
                   params = map(run_id, function(x) list_params %>% map_dbl(., x)))

# create a new column that stores the results from the ode() projection
mytibble %>%
   mutate(ode_proj = pmap(list(y = inits.outbreak, parms = params), ode, times = seq(0, 120, by = 1), func = simple_sirs_with_cumulative)) %>% 
   # now create another column that stores the equilibrium for these:
   mutate(steady_state = pmap(list(y = inits.steady, parms = params), runsteady, func = simple_sirs)) -> sirs_results # save as new object

slice_head(sirs_results, n = 3)
```

From our results we can visualize the proportion of infected individuals over time for each of the runs:
```{r}
# get results in proper format:
sirs_results %>%
   mutate(ode_df = map(ode_proj, as.data.frame)) %>%
   pull(ode_df) %>%
   list_rbind(names_to = "run_id") -> ode_df

ode_df %>%
   ggplot(., aes(x = time, y = I_wild, group = run_id)) +
   geom_line() +
   labs(x = "Time in days", y = "Proportion of infected, wild individuals") +
   theme_bw()
```

We can calculate the cumulative proportion of the population that is infected over the course of the projection:
```{r}
# get results in proper format:
sirs_results %>%
   mutate(ode_df = map(ode_proj, as.data.frame)) %>%
   pull(ode_df) %>%
   list_rbind(names_to = "run_id") -> ode_df

ode_df %>%
   ggplot(., aes(x = time, y = I_wild_cumulative, group = run_id)) +
   geom_line() +
   labs(x = "Time in days", y = "Proportion of I_w individuals") +
   theme_bw()
```

We can also take a look at how all compartments change over time: 
```{r}

ode_df %>%
   select(., -I_wild_cumulative, -I_captive_cumulative) %>% 
   pivot_longer(cols = -c(run_id, time), names_to = "compartment") %>%
   ggplot(., aes(x = time, y = value, group = run_id)) +
   facet_wrap(~compartment) +
   geom_line() +
   labs(x = "Time in days", y = "Proportion of population") +
   theme_bw()
```


And check the steady state, or equilibrium, for all of these runs: 

```{r}
sirs_results %>%
   mutate(steady_sir = map(steady_state, "y"),
          steady_sir = map(steady_sir, as_tibble_row)) %>% 
   pull(steady_sir) %>% 
   list_rbind(names_to = "run_id") -> steady_sir

steady_sir %>% 
   pivot_longer(cols = -run_id, names_to = "compartment", values_to = "proportion") %>% 
   separate(compartment, sep = "_", c("sir_type", "pop_type")) %>% 
   mutate(sir_type = factor(sir_type, levels = c("S", "I", "R")),
          pop_type = factor(pop_type, levels = c("wild", "captive"))) %>% 
   ggplot(aes(y = proportion, color = pop_type, x = sir_type)) +
   geom_boxplot() +
   ylim(0, 1) +
   labs(x = "", color = "Population Type", y = "Proportion at equilibrium") +
   theme_bw()
```


We can also calculate some metrics such as R0 and force of infection (FOI): 

```{r}
r0_deer <- ((c_ww * nu_aero_deer_deer) + (c_ww * nu_dc_deer_deer * sigma_dc_wild)) * 1/gamma_recov
r0_human <- c_hw * nu_aero_deer_human_rural * 9.5

tibble(r0_deer = r0_deer, r0_human = r0_human) %>% 
   pivot_longer(cols = everything()) %>% 
   ggplot(., aes(y = value)) +
   facet_wrap(~ name, scales = "free") +
   geom_hline(yintercept = 0.0015, color = "red", linetype = "dashed") +
   geom_boxplot() +
   theme_bw() +
   theme(axis.text.x = element_blank())
```

```{r}
#FOI
foi <- c_hw * nu_aero_deer_human_rural * I_human

ggplot(data = tibble(foi = foi), aes(y = foi)) +
   geom_boxplot() +
   theme_bw() +
   theme(axis.text.x = element_blank())
```

